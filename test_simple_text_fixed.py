# Self-contained ManimCE snippet for scene: SimpleText
# From video: inventing-math

from manim import *
import numpy as np
from typing import Optional, List, Dict, Union, Any
from functools import reduce
import string
import itertools as it
from copy import deepcopy
from random import sample
import itertools as it
import operator as op
import random
import sys


# Helper functions

def initials(word_list):
    """Extract first letter of each word from a list of characters"""
    words = ''.join(word_list).split()
    return ''.join([w[0] for w in words if w])

def divergent_sum():
    return MathTex(''.join(DIVERGENT_SUM_TEXT)).scale(2)


def Underbrace(left, right):
    result = Tex('\\Underbrace{%s}' % (14 * '\\quad'))
    result.stretch_to_fit_width(right[0] - left[0])
    result.shift(left - result.points[0])
    return result


def zero_to_one_interval():
    interval = NumberLine()
    zero = Tex('0').shift(INTERVAL_RADIUS * (DOWN + LEFT))
    one = Tex('1').shift(INTERVAL_RADIUS * (DOWN + RIGHT))
    return VGroup(interval, zero, one)


def draw_you(with_bubble=False):
    result = Circle(radius=0.5, color=GRAY)
    result.to_corner(LEFT + DOWN)
    if with_bubble:
        bubble = RoundedRectangle(width=3, height=2, corner_radius=0.3)
        bubble.next_to(result, UP)
        return (result, bubble)
    return result


def partial_sum(n):
    return sum([(1.0 / (2 ** (k + 1))) for k in range(n)])


def get_room_colors():
    return list([YELLOW, ORANGE, RED, DARK_RED])


def convergent_sum():
    return MathTex(''.join(CONVERGENT_SUM_TEXT)).scale(2)


# Constants
NUM_INTERVAL_TICKS = 16
INTERVAL_RADIUS = 5
DIVERGENT_SUM_TEXT = ['1', '+2', '+4', '+8', '+\\cdots', '+2^n', '+\\cdots', '= -1']
CONVERGENT_SUM_TEXT = ['\\frac{1}{2}', '+\\frac{1}{4}', '+\\frac{1}{8}', '+\\frac{1}{16}', '+\\cdots', '+\\frac{1}{2^n}', '+\\cdots', '=1']
PARTIAL_CONVERGENT_SUMS_TEXT = ['\\frac{1}{2}', ', ', ',\\quad', '\\frac{1}{2} + \\frac{1}{4}', '=', '\\frac{3}{4}', ',\\quad', '\\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8}', '=', '\\frac{7}{8}', ',\\quad', '\\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} + \\frac{1}{16}', '=', '\\frac{15}{16}', ',\\dots']
NUM_WRITTEN_TERMS = 4
SUM_SPACING = 0.25
CONVERGENT_SUM_TERMS = ['\\frac{1}{2}', '\\frac{1}{4}', '\\frac{1}{8}', '\\frac{1}{16}']
ALT_PARTIAL_SUM_TEXT = reduce(op.add, [[str(partial_sum(n)), '&=', '+'.join(CONVERGENT_SUM_TERMS[:n]) + '\\\\'] for n in range(1, len(CONVERGENT_SUM_TERMS) + 1)]) + ['\\vdots', '&', '\\\\', '1.0', '&=', '+'.join(CONVERGENT_SUM_TERMS) + '+\\cdots+\\frac{1}{2^n}+\\cdots']

# Custom animations
class FlipThroughNumbers(Animation):
    def __init__(self, func, start=0, end=10, start_center=ORIGIN, 
                 end_center=ORIGIN, **kwargs):
        self.func = func
        self.start = start
        self.end = end
        self.start_center = start_center
        self.end_center = end_center
        self.current_number = start
        self.number = Text(str(func(start)))
        self.number.move_to(start_center)
        super().__init__(self.number, **kwargs)
        
    def interpolate_mobject(self, alpha):
        self.current_number = int(self.start + alpha * (self.end - self.start))
        new_text = str(self.func(self.current_number))
        new_center = self.start_center + alpha * (self.end_center - self.start_center)
        
        # Update the text
        self.mobject.become(Text(new_text))
        self.mobject.move_to(new_center)


'\nfrom manim import *\n\nSelf-contained scene: SimpleText\nGenerated by programmatic cleaner\nDependencies: 0 functions, 0 classes, 0 constants\n'

class SimpleText(Scene):
    args_list = [('Build the foundation of what we know'), ('What would that feel like?'), ('Arbitrary decisions hinder generality'), ('Section 1: Discovering and Defining Infinite Sums'), ('Section 2: Seeking Generality'), ('Section 3: Redefining Distance'), ("``Approach''?"), ('Rigor would dictate you ignore these'), ('dist($A$, $B$) = dist($A+x$, $B+x$) \\quad for all $x$'), ('How does a useful distance function differ from a random function?'), ('Pause now, if you like, and see if you can invent your own distance function from this.'), ('$p$-adic metrics \\\\ ($p$ is any prime number)'), ('This is not meant to match the history of discoveries')]

    @staticmethod
    def args_to_string(text):
        return initials([c for c in text if (c in (string.ascii_letters + ' '))])

    def _construct_with_args(self, text):
        self.add(Text(text))

    def construct(self):
        '# Converted from parameterized scene - using first args_list entry'
        self._construct_with_args('Build the foundation of what we know')